#pragma kernel CSMain

struct TerraninData
{    
    //当前坐标
    float2 position;
    //频率（宽度）
    float perlinFrequency;
    //振幅(高度) 
    float perlinAmplitude;
    //循环大小 最好大于512
    float perlinSize;    
    //迭代次数（越多地图越复杂）
    int perlinIterateNumber;
    //最低高度
    float minHeight;

    //距离该方块最近的生态点距离
    float minBiomeDis;
    //距离该方块第二近的生态点距离
    float secondMinBiomeDis;
    //距离最近和第二进的距离差
    float offsetDis;
    //地形最大高度
    float maxHeight;
};

//种子偏移
float2 RandomOffset;
//地形数据
RWStructuredBuffer<TerraninData> BufferTerraninData;

////生态中心方块坐标
//float3 ArrayBiomeCenterPosition[100];

//unity noisemap生成算法
float2 unity_gradientNoise_dir(float2 p)
{
    p = p % 289;
    float x = (34 * p.x + 1) * p.x % 289 + p.y;
    x = (34 * x + 1) * x % 289;
    x = frac(x / 41) * 2 - 1;
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

//unity noisemap生成算法
float unity_gradientNoise(float2 p)
{
    float2 ip = floor(p);
    float2 fp = frac(p);
    float d00 = dot(unity_gradientNoise_dir(ip), fp);
    float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
    float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
    float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

//计算距离
float Unity_Distance_float3(float3 A, float3 B)
{
    return distance(A, B);
}

[numthreads(1024,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID,uint3 gid:SV_GROUPID,uint index:SV_GROUPINDEX)
{
    //获取GPU运算线程的地形数据
    int dataIndex = id.x;
    TerraninData itemTerraninData = BufferTerraninData[dataIndex];

    int iterateNumber = 0;
    float curFrequency = itemTerraninData.perlinFrequency;
    float curAmplitude = itemTerraninData.perlinAmplitude;
    float finalNoise = 0;
    //循环种子次数
    while(itemTerraninData.perlinIterateNumber > iterateNumber)
    {
        float x0 = (itemTerraninData.position.x / itemTerraninData.perlinSize) * curFrequency;
        float y0 = (itemTerraninData.position.y / itemTerraninData.perlinSize) * curFrequency;

        float noise0 = unity_gradientNoise(float2(x0 + RandomOffset.x , y0 + RandomOffset.y)) * curAmplitude;

        finalNoise = finalNoise + noise0;
        iterateNumber = iterateNumber + 1;
        curFrequency = curFrequency * 2;
        curAmplitude = curAmplitude / 2;
    }

    ////距离该方块最近的生态点距离
    //float minBiomeDis = 3.40282e+038;
    ////距离该方块第二近的生态点距离
    //float secondMinBiomeDis = 3.40282e+038;
    ////最靠近的生态点
    //float3 minBiomePosition = float3(0,0,0);

    //int biomeCenterNumber = 0;
    // //遍历中心点，寻找最靠近的生态点（维诺图）
    //while(biomeCenterNumber < 100)
    //{
    //    float3 itemCenterPosition = ArrayBiomeCenterPosition[biomeCenterNumber];
    //    //如果有这个中心点
    //    if(itemCenterPosition.x != 0 && itemCenterPosition.y != 0 && itemCenterPosition.z != 0)
    //    {
    //        float3 itemPosition3 = float3(itemTerraninData.position.x , itemTerraninData.position.y , 0);
    //        float tempDis = Unity_Distance_float3(itemPosition3, itemCenterPosition);

    //        //如果小于最小距离
    //        if (tempDis <= minBiomeDis)
    //        {
    //            minBiomePosition = itemCenterPosition;
    //            minBiomeDis = tempDis;
    //        }
    //        //如果大于最小距离 并且小于第二小距离
    //        else if (tempDis > minBiomeDis && tempDis <= secondMinBiomeDis)
    //        {
    //            secondMinBiomeDis = tempDis;
    //        }
    //    }
    //    biomeCenterNumber++;
    //}
       
    //itemTerraninData.minBiomeDis = minBiomeDis;
    //itemTerraninData.secondMinBiomeDis = secondMinBiomeDis;

    itemTerraninData.offsetDis = itemTerraninData.secondMinBiomeDis - itemTerraninData.minBiomeDis;
    itemTerraninData.maxHeight =  itemTerraninData.minHeight + finalNoise;
    //边缘处理 逐渐减缓到最低高度
    if (itemTerraninData.offsetDis <= 10) //在20范围以内
    {
        itemTerraninData.maxHeight = ceil((itemTerraninData.maxHeight - itemTerraninData.minHeight) /10) * ceil(itemTerraninData.offsetDis) + itemTerraninData.maxHeight;
    }

    BufferTerraninData[dataIndex] = itemTerraninData;

}


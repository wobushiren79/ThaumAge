#pragma kernel CSMain

struct TerraninData
{    
    //当前坐标
    float2 position;
    //地形最大高度
    int maxHeight;
    //当前生态
    int biomeIndex;
};

struct BiomeData
{    
    //频率（宽度）
    float perlinFrequency0;
    float perlinFrequency1;
    float perlinFrequency2;
    //振幅(高度) 
    float perlinAmplitude0;
    float perlinAmplitude1;
    float perlinAmplitude2;
    //循环大小 最好大于512
    float perlinSize0;
    float perlinSize1;   
    float perlinSize2;       
    //迭代次数（越多地图越复杂）
    int perlinIterateNumber0;
    int perlinIterateNumber1;
    int perlinIterateNumber2;
    //最低高度
    float minHeight;
};

//种子偏移
int RandomSeed;
//生态数量
int BiomeNum;
//生态大小
int BiomeSize;
//地形数据
RWStructuredBuffer<TerraninData> BufferTerraninData;
//生态数据
RWStructuredBuffer<BiomeData> BufferBiomeData;

//unity noisemap生成算法
float2 Unity_GradientNoise_dir(float2 p)
{
    p = p % 289;
    float x = (34 * p.x + 1) * p.x % 289 + p.y;
    x = (34 * x + 1) * x % 289;
    x = frac(x / 41) * 2 - 1;
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

//unity noisemap生成算法
float Unity_GradientNoise(float2 p)
{
    float2 ip = floor(p);
    float2 fp = frac(p);
    float d00 = dot(Unity_GradientNoise_dir(ip), fp);
    float d01 = dot(Unity_GradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
    float d10 = dot(Unity_GradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
    float d11 = dot(Unity_GradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

//计算距离
float Unity_Distance_float3(float3 A, float3 B)
{
    return distance(A, B);
}

//随机数
int RandomInt(int seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
//随机数
int RandomIntMinMax(int seed, int min, int max)
{
    int randomInt = RandomInt(seed);
    int randomLimit = (max - min)/(2147483647/(float)randomInt);
    return randomLimit;
}
//随机数
int RandomInt(int seed,int x,int y)
{
    seed = seed + 76.897898 * 48.789789 *  cos(x) * sin(y) * 20.79797;
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}
//随机数
int RandomIntMinMax(int seed,int x,int y, int min, int max)
{
    int randomInt = RandomInt(seed,x,y);
    int randomLimit = (max - min)/(2147483647/(float)randomInt);
    return randomLimit;
}

//地形生成
float TerraninCreate(int iterateNumberMax,float perlinFrequency,float perlinAmplitude,float perlinSize,float posX,float posY)
{
    float finalNoise = 0;
    int iterateNumber = 0;
    float curFrequency = perlinFrequency;
    float curAmplitude = perlinAmplitude;

    int curRandomSeedOffset = RandomSeed % (BiomeSize * 7);
    //循环种子次数
    while(iterateNumberMax > iterateNumber)
    {
        float x0 = (posX / perlinSize) * curFrequency;
        float y0 = (posY / perlinSize) * curFrequency;

        float noise0 = Unity_GradientNoise(float2(x0 + curRandomSeedOffset, y0 + curRandomSeedOffset)) * curAmplitude;
        //float noise0 = Unity_GradientNoise(float2(x0, y0)) * curAmplitude;
        finalNoise = finalNoise + noise0;
        iterateNumber = iterateNumber + 1;
        curFrequency = curFrequency * 2;
        curAmplitude = curAmplitude / 2;
        curRandomSeedOffset = curRandomSeedOffset / 2;
    }
    return finalNoise;
}

//获取六边形地形位置
float3 GetHexagonBiomeWorldPos(int x, int y, float sideLength, float sideHeight)
{
    float wx = x * (sideLength * 1.5f);
    float wz = abs((x % 2)) * sideHeight + y * sideHeight * 2;
    return float3(wx,0,wz);
}

//获取第二近的生态数据
void GetSecondBiomeData(float x, float y, int2 disMinPosIndex, float sideLength, float sideHeight,
    out int2 disSecondPosIndex, out float disSecond, out float3 disSecondPos)
{
    int2 index1;
    int2 index2;
    int2 index3;

    int2 index4;
    int2 index5;
    int2 index6;

    //获取上下左右6个区块的位置
    //不同的index 周边的6个区块各部相同
    if (disMinPosIndex.x % 2 == 0)
    {
        index1 = int2(disMinPosIndex.x + 1, disMinPosIndex.y);
        index2 = int2(disMinPosIndex.x, disMinPosIndex.y + 1);
        index3 = int2(disMinPosIndex.x + 1, disMinPosIndex.y - 1);

        index4 = int2(disMinPosIndex.x - 1, disMinPosIndex.y);
        index5 = int2(disMinPosIndex.x, disMinPosIndex.y - 1);
        index6 = int2(disMinPosIndex.x - 1, disMinPosIndex.y - 1);
    }
    else 
    {
        index1 = int2(disMinPosIndex.x + 1, disMinPosIndex.y);
        index2 = int2(disMinPosIndex.x, disMinPosIndex.y + 1);
        index3 = int2(disMinPosIndex.x + 1, disMinPosIndex.y + 1);

        index4 = int2(disMinPosIndex.x - 1, disMinPosIndex.y);
        index5 = int2(disMinPosIndex.x, disMinPosIndex.y - 1);
        index6 = int2(disMinPosIndex.x - 1, disMinPosIndex.y + 1);
    }

    float3 worldPos1 = GetHexagonBiomeWorldPos(index1.x, index1.y, sideLength, sideHeight);
    float3 worldPos2 = GetHexagonBiomeWorldPos(index2.x, index2.y, sideLength, sideHeight);
    float3 worldPos3 = GetHexagonBiomeWorldPos(index3.x, index3.y, sideLength, sideHeight);

    float3 worldPos4 = GetHexagonBiomeWorldPos(index4.x, index4.y, sideLength, sideHeight);
    float3 worldPos5 = GetHexagonBiomeWorldPos(index5.x, index5.y, sideLength, sideHeight);
    float3 worldPos6 = GetHexagonBiomeWorldPos(index6.x, index6.y, sideLength, sideHeight);

    disSecond = 999999;
    float disPos1 = distance(worldPos1, float3(x, 0, y));
    if (disPos1 <= disSecond)
    {
        disSecond = disPos1;
        disSecondPos = worldPos1;
        disSecondPosIndex = index1;
    }

    float disPos2 = distance(worldPos2, float3(x, 0, y));
    if (disPos2 <= disSecond)
    {
        disSecond = disPos2;
        disSecondPos = worldPos2;
        disSecondPosIndex = index2;
    }

    float disPos3 = distance(worldPos3, float3(x, 0, y));
    if (disPos3 <= disSecond)
    {
        disSecond = disPos3;
        disSecondPos = worldPos3;
        disSecondPosIndex = index3;
    }

    float disPos4 = distance(worldPos4, float3(x, 0, y));
    if (disPos4 <= disSecond)
    {
        disSecond = disPos4;
        disSecondPos = worldPos4;
        disSecondPosIndex = index4;
    }

    float disPos5 = distance(worldPos5, float3(x, 0, y));
    if (disPos5 <= disSecond)
    {
        disSecond = disPos5;
        disSecondPos = worldPos5;
        disSecondPosIndex = index5;
    }

    float disPos6 = distance(worldPos6, float3(x, 0, y));
    if (disPos6 <= disSecond)
    {
        disSecond = disPos6;
        disSecondPos = worldPos6;
        disSecondPosIndex = index6;
    }
}

//获取任意坐标六边形下标
void GetHexagonBiomeIndex(float x, float y, float sideLength, float sideHeight,
    out int2 disMinPosIndex, out float disMin, out float3 disMinPos,
    out int2 disSecondPosIndex, out float disSecond, out float3 disSecondPos)
{
    float offsetPositionX = x;
    float offsetPositionY = y;

    int indexX;
    int indexY;

    int addIndexX;
    int addIndexY;

    if (offsetPositionX >= 0)
    {
        indexX = floor(offsetPositionX / (sideLength * 1.5f));
        addIndexX = 1;
    }
    else
    {
        indexX = ceil(offsetPositionX / (sideLength * 1.5f));
        addIndexX = -1;
    }
    if (offsetPositionY >= 0)
    {
        indexY = floor(offsetPositionY / (sideHeight * 2));
        addIndexY = 1;
    }
    else
    {
        indexY = ceil(offsetPositionY / (sideHeight * 2));
        addIndexY = -1;
    }


    //获取上下左右4个区块的位置
    float3 worldPos1 = GetHexagonBiomeWorldPos(indexX, indexY, sideLength, sideHeight);
    float3 worldPos2 = GetHexagonBiomeWorldPos(indexX + addIndexX, indexY, sideLength, sideHeight);
    float3 worldPos3 = GetHexagonBiomeWorldPos(indexX, indexY + addIndexY, sideLength, sideHeight);
    float3 worldPos4 = GetHexagonBiomeWorldPos(indexX + addIndexX, indexY + addIndexY, sideLength, sideHeight);

    disMinPosIndex = int2(0, 0);
    disSecondPosIndex = int2(0, 0);

    disMin = 9999998;
    disSecond = 9999999;

    disMinPos = float3(0, 0, 0);
    disSecondPos = float3(0, 0, 0);

    float disPos1 = distance(worldPos1, float3(x, 0, y));
    if (disPos1 <= disMin)
    {
        disMin = disPos1;
        disMinPos = worldPos1;
        disMinPosIndex.x = indexX;
        disMinPosIndex.y = indexY;
    }

    float disPos2 = distance(worldPos2, float3(x, 0, y));
    if (disPos2 <= disMin)
    {
        disMin = disPos2;
        disMinPos = worldPos2;
        disMinPosIndex.x = indexX + addIndexX;
        disMinPosIndex.y = indexY;
    }

    float disPos3 = distance(worldPos3, float3(x, 0, y));
    if (disPos3 <= disMin)
    {
        disMin = disPos3;
        disMinPos = worldPos3;
        disMinPosIndex.x = indexX;
        disMinPosIndex.y = indexY + addIndexY;
    }

    float disPos4 = distance(worldPos4, float3(x, 0, y));
    if (disPos4 <= disMin)
    {
        disMin = disPos4;
        disMinPos = worldPos4;
        disMinPosIndex.x = indexX + addIndexX;
        disMinPosIndex.y = indexY + addIndexY;
    }

    GetSecondBiomeData(x, y, disMinPosIndex, sideLength, sideHeight, disSecondPosIndex, disSecond, disSecondPos);
}


[numthreads(1024,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID,uint3 gid:SV_GROUPID,uint index:SV_GROUPINDEX)
{
    //获取GPU运算线程的地形数据
    int dataIndex = id.x;
    TerraninData itemTerraninData = BufferTerraninData[dataIndex];

    //距离最远的生态
    int2 disMinPosIndex;
    float disMin;
    float3 disMinPos;

    //距离第二远的生态
    int2 disSecondPosIndex;
    float disSecond;
    float3 disSecondPos;

   //获取该点所在的生态下标
    GetHexagonBiomeIndex(itemTerraninData.position.x, itemTerraninData.position.y, BiomeSize,sqrt(3) * 0.5  * BiomeSize,
         disMinPosIndex, disMin, disMinPos,
         disSecondPosIndex, disSecond, disSecondPos);
    //随机获取生态
    
    int randomBiomeIndexMin = RandomIntMinMax(RandomSeed , disMinPosIndex.x , disMinPosIndex.y , 0 , BiomeNum);
    int randomBiomeIndexSecond = RandomIntMinMax(RandomSeed, disSecondPosIndex.x, disSecondPosIndex.y, 0, BiomeNum);

    itemTerraninData.biomeIndex = randomBiomeIndexMin;

    //当前生态信息
    BiomeData biomeData =  BufferBiomeData[randomBiomeIndexMin];
    //第二近的生态信息
    BiomeData biomeDataSecond =  BufferBiomeData[randomBiomeIndexSecond];

    float finalNoise0 =  TerraninCreate(
        biomeData.perlinIterateNumber0,
        biomeData.perlinFrequency0,
        biomeData.perlinAmplitude0,
        biomeData.perlinSize0,
        itemTerraninData.position.x,
        itemTerraninData.position.y);

    float finalNoise1 =  TerraninCreate(
        biomeData.perlinIterateNumber1,
        biomeData.perlinFrequency1,
        biomeData.perlinAmplitude1,
        biomeData.perlinSize1,
        itemTerraninData.position.x,
        itemTerraninData.position.y);

    float finalNoise2 =  TerraninCreate(
        biomeData.perlinIterateNumber2,
        biomeData.perlinFrequency2,
        biomeData.perlinAmplitude2,
        biomeData.perlinSize2,
        itemTerraninData.position.x,
        itemTerraninData.position.y);

    float finalNoise = finalNoise0;

    if (biomeData.perlinIterateNumber1 > 0) 
    {
        finalNoise = finalNoise0 > finalNoise1 ? finalNoise0 : finalNoise1;
    }
    if (biomeData.perlinIterateNumber2 > 0)
    {
        finalNoise = finalNoise > finalNoise2 ? finalNoise : finalNoise2;
    }
 
    itemTerraninData.maxHeight =  (int)(biomeData.minHeight + finalNoise);

     //计算不同生态切换之间的融合 都以64高度为基础
    float baseHeight = 65;
    float lerpSize = 10;
    
    if(randomBiomeIndexMin != randomBiomeIndexSecond && disSecond - disMin <= lerpSize)
    {
        itemTerraninData.maxHeight = (int)lerp(baseHeight, (float)itemTerraninData.maxHeight, (disSecond - disMin) / lerpSize);
    }
    BufferTerraninData[dataIndex] = itemTerraninData;
}


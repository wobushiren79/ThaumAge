// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel StartCreate

#include "Noise/SimplexNoiseCShader.compute"
#include "Biome/BiomeForestCShader.compute"
#include "Biome/BiomePrairieCShader.compute"
#include "Biome/BiomeDesertCShader.compute"
#include "Biome/BiomeMountainCShader.compute"
#include "Biome/BiomePrairieLavaCShader.compute"
#include "Biome/BiomeOceanCShader.compute"
#include "Biome/BiomeForestBirchCShader.compute"
#include "Biome/BiomeForestMagicCShader.compute"
#include "Biome/BiomeSnowlandCShader.compute"
#include "Biome/BiomeSwampCShader.compute"
#include "Biome/BiomeTestCShader.compute"
#include "Biome/BiomeMainCShader.compute"
#include "Biome/BiomePutrefyDungeonBaseCShader.compute"
//方块数据
struct BlockData
{
	//方块ID
	int blockId;
	//方块的结构 0普通方块
	int blockStructure;
};

//noise数据
struct NoiseLayer
{
	//生态ID
	int biomeId;
	//出现频率 数值越大 波峰越多
	float frequency;
	//振幅 数值越大 越宽
	float amplitude;
	//间隙性
	float lacunarity;
	//噪音循环迭代次数 复杂度
	int octaves;

	//洞穴高度
	int caveMinHeight;
	int caveMaxHeight;
	//洞穴大小
	float caveScale;
	//洞穴的阈值
	float caveThreshold;

	//洞穴出现频率 数值越大 波峰越多
	float caveFrequency;
	//洞穴振幅 数值越大 越宽
	float caveAmplitude;
	//洞穴循环迭代次数 复杂度
	int caveOctaves;

	//地面的最低高度
	int groundMinHeigh;
	//海面高度
	int oceanMinHeight;
	int oceanMaxHeight;
	//水的大小
	float oceanScale;
	//水的预制
	float oceanThreshold;
	//水的振幅 
	float oceanAmplitude;
	//水的频率 
	float oceanFrequency;
};

//矿石数据
struct OreData
{
	//矿石ID
	int oreId;
	//矿石密度
	float oreDensity;
	//矿石的范围
	int oreMinHeight;
	int oreMaxHeight;
};

//2D地形数据
struct Terrain2DData
{
	//高度
	uint height;
	//使用的noiseIndex
	uint noiseIndex;
};

//区块宽
uint chunkSizeW;
//区块高
uint chunkSizeH;
/*
洞穴状态
0 不创建洞穴
1 创建普通洞穴
*/
uint stateCaves;
/*
基岩状态
0 不创建基岩
1 创建普通基岩 y=0
*/
uint stateBedrock;
//区块位置
float3 chunkPosition;
//种子
int seed;
//种子偏移
float3 seedOffset;
//所有noise数据
StructuredBuffer<NoiseLayer> noiseLayersArrayBuffer;
int noiseLayersCount;
//矿石数据
StructuredBuffer<OreData> oreDatasArrayBuffer;
int oreDatasCount;
//所有的方块列表数据
RWStructuredBuffer<BlockData> blockArrayBuffer;
//不是空气方块的数量
RWStructuredBuffer<uint> blockCountBuffer;

//获取方块的序号
int GetBlockIndex(uint3 idx)
{
	return idx.x + (idx.y * chunkSizeW) + (idx.z * chunkSizeW * chunkSizeH);
}

//创建3D地形数据 暂时用于洞穴
float CreateTerrainCaveData(float3 blockPos, float terrainHeight, uint noiseIndex)
{
	//获取当前noise数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];

	float amplitude = 1;
	float frequency = 1;

	//3D地形的权重
	float weightCave = 0;

	//迭代次数
	for (int i = 0; i < selectedNoise.caveOctaves; i++)
	{
		weightCave += snoise(frequency * (blockPos / selectedNoise.caveScale)) * amplitude;
		frequency *= selectedNoise.caveFrequency;
		amplitude *= selectedNoise.caveAmplitude;
	}
	return weightCave;
}

//获取指定位置 2D地形的高度权重
float CreateTerrain2DWeightH(float2 blockPosXZ, uint noiseIndex)
{
	//获取当前noise数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];
	float weightH = 0;
	float amplitude = selectedNoise.amplitude;
	float3 posTempData = float3(blockPosXZ.xy, seed);
	//容错处理 0，0位置的高度有问题 使用1，1的高度
	if (posTempData.x == 0 && posTempData.y == 0)
	{
		posTempData.x = 1;
		posTempData.y = 0;
	}
	//迭代次数
	for (int i = 0; i < selectedNoise.octaves; i++)
	{
		//调取噪音计算 获取2D的权重高度 这里加上振幅和频率
		if (selectedNoise.frequency == 0)
		{
			//如果频率为0 则为0高度
			weightH += 0;
		}
		else
		{
			weightH += snoise(float3(posTempData.xy / selectedNoise.frequency, posTempData.z)) * amplitude;
		}
		//每次迭代改变间隙性
		posTempData.xy *= selectedNoise.lacunarity;
		//每次迭代改变振幅
		amplitude *= selectedNoise.amplitude;
	}
	weightH = weightH * weightH;
	return clamp(weightH, 0, 1);
}

//创建2D的地形数据
Terrain2DData CreateTerrain2DData(float3 blockPos)
{
	//噪音数据的序号  TODO 暂时只处理第一个
	uint noiseIndex = 0;
	//获取2D地形的权重高
	float weightH = CreateTerrain2DWeightH(blockPos.xz, noiseIndex);
	//获取当前的noise参数
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];
	//做一个容错。最高不超过区块的高-16
	float height = clamp((weightH * (chunkSizeH - 32)) + selectedNoise.groundMinHeigh, 0, chunkSizeH - 16);

	//获取左右前后的数据
	NoiseLayer selectedNoiseL = noiseLayersArrayBuffer[1];
	NoiseLayer selectedNoiseR = noiseLayersArrayBuffer[2];
	NoiseLayer selectedNoiseF = noiseLayersArrayBuffer[3];
	NoiseLayer selectedNoiseB = noiseLayersArrayBuffer[4];

	float posLocalX = blockPos.x - chunkPosition.x;
	float posLocalZ = blockPos.z - chunkPosition.z;

	float lerpHeightL = 0;
	float lerpHeightR = 0;
	float lerpHeightF = 0;
	float lerpHeightB = 0;
	//过度总数
	int lerpHeightMin = chunkSizeH + 1;
	//过度的方块数量
	int lerpBlockNum = 5;
	int curOceanMaxHeight = (selectedNoise.oceanMaxHeight <= 0 ? 64 : selectedNoise.oceanMaxHeight);
	if (selectedNoiseL.biomeId != selectedNoise.biomeId && posLocalX >= 0 && posLocalX < lerpBlockNum)
	{
		int otherOceanMaxHeight = (selectedNoiseL.oceanMaxHeight <= 0 ? 64 : selectedNoiseL.oceanMaxHeight);
		float baseHeight = (curOceanMaxHeight + otherOceanMaxHeight) / (float)2;
		lerpHeightL = lerp(height, baseHeight, 1 - (posLocalX / (lerpBlockNum - 1)));
		lerpHeightMin = lerpHeightL < lerpHeightMin ? lerpHeightL : lerpHeightMin;
	}
	if (selectedNoiseR.biomeId != selectedNoise.biomeId && posLocalX >= (chunkSizeW - lerpBlockNum) && posLocalX < chunkSizeW)
	{		
		int otherOceanMaxHeight = (selectedNoiseR.oceanMaxHeight <= 0 ? 64 : selectedNoiseR.oceanMaxHeight);
		float baseHeight = (curOceanMaxHeight + otherOceanMaxHeight) / (float)2;
		lerpHeightR = lerp(height, baseHeight, (posLocalX - (chunkSizeW - lerpBlockNum)) / (lerpBlockNum - 1));
		lerpHeightMin = lerpHeightR < lerpHeightMin ? lerpHeightR : lerpHeightMin;
	}
	if (selectedNoiseF.biomeId != selectedNoise.biomeId && posLocalZ >= 0 && posLocalZ < lerpBlockNum)
	{
		int otherOceanMaxHeight = (selectedNoiseF.oceanMaxHeight <= 0 ? 64 : selectedNoiseF.oceanMaxHeight);
		float baseHeight = (curOceanMaxHeight + otherOceanMaxHeight) / (float)2;
		lerpHeightF = lerp(height, baseHeight, 1 - (posLocalZ / (lerpBlockNum - 1)));
		lerpHeightMin = lerpHeightF < lerpHeightMin ? lerpHeightF : lerpHeightMin;
	}
	if (selectedNoiseB.biomeId != selectedNoise.biomeId && posLocalZ >= (chunkSizeW - lerpBlockNum) && posLocalZ < chunkSizeW)
	{
		int otherOceanMaxHeight = (selectedNoiseB.oceanMaxHeight <= 0 ? 64 : selectedNoiseB.oceanMaxHeight);
		float baseHeight = (curOceanMaxHeight + otherOceanMaxHeight) / (float)2;
		lerpHeightB = lerp(height, baseHeight, (posLocalZ - (chunkSizeW - lerpBlockNum)) / (lerpBlockNum - 1));
		lerpHeightMin = lerpHeightB < lerpHeightMin ? lerpHeightB : lerpHeightMin;
	}

	if (lerpHeightMin != chunkSizeH + 1)
	{
		height = lerpHeightMin;
	}

	Terrain2DData terrain2DData;
	terrain2DData.height = round(height);
	terrain2DData.noiseIndex = noiseIndex;
	return terrain2DData;
}

//创建3D定性数据 用于水
float CreateTerrainOceanData(float3 blockPos, float terrainHeight, uint noiseIndex)
{	
	//获取当前noise数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];
	float weighOcean = 0;
	//迭代次数
	weighOcean += snoise(selectedNoise.oceanFrequency * (blockPos / selectedNoise.oceanScale)) * selectedNoise.oceanAmplitude;
	return weighOcean;
}

//根据生态生成数据 测试用
int4 HandleBiomeTest(int seed, float3 blockPos, int blockIndex, uint terrainHeight, 
	bool isBlockCave, bool isBlockCaveDown,float weighOceanTarget, float weighOcean,float weighOceanDown)
{
	int4 targetBlockData = int4(0, 0, 0, 0);
	//处理边界
	if(blockPos.x > 128 || blockPos.x < -128 || blockPos.z > 128 || blockPos.z < -128)
	{
		if(blockPos.y > 64)
		{
			//使用空气
			targetBlockData = int4(0, 0, 0, 1);
		}
		else
		{
			//使用地基
			targetBlockData = int4(1, 0, 0, 1);
		}
		return targetBlockData;
	}

	//如果大于地面高度
	if (blockPos.y > terrainHeight)
	{
		//如果是地面上一格
	    if (blockPos.y == terrainHeight + 1)
		{
			targetBlockData = int4(0, 0, 0, 1);
		}
		else
		{
			targetBlockData = int4(0, 0, 0, 1);
		}
	}
	else if (blockPos.y == terrainHeight)
	{
		//使用泥土
		targetBlockData = int4(101, 0, 0, 1);
	}
	else
	{
		//使用石头
		targetBlockData = int4(5, 0, 0, 1);
	}
	return targetBlockData;
}

//开始生成数据
[numthreads(8, 8, 8)]
void StartCreate(uint3 id : SV_DispatchThreadID)
{
	//如果XZ大于W 则不处理
	if (any(id.xz > chunkSizeW))
		return;
	//获取方块下标
	int blockIndex = GetBlockIndex(id);
	//获取方块的世界坐标
	float3 blockPos = id + chunkPosition + seedOffset;
	//获取2D地形数据
	Terrain2DData terrain2DData = CreateTerrain2DData(blockPos);
	//获取2D地形的高
	uint terrainHeight = terrain2DData.height;
	//获取噪音数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[terrain2DData.noiseIndex];

	BlockData itemBlock;
	itemBlock.blockId = 0;
	itemBlock.blockStructure = 0;

	//当前方块是否是洞穴
	bool isBlockCave = false;
	//下方方块是否是洞穴
	bool isBlockCaveDown = false;

	//权重 水
	float weighOcean = 0;
	float weighOceanDown = 0;
	//如果不是空气方块 并且在地表以下 则创建普通洞穴
	if (blockPos.y <= terrainHeight + 1)
	{
		if (blockPos.y >= selectedNoise.caveMinHeight && blockPos.y <= selectedNoise.caveMaxHeight)
		{
			//如果是需要创建普通洞穴
			switch (stateCaves)
			{
			case 1:
				//如果大于阈值则是空气
				float weightCave = CreateTerrainCaveData(blockPos, terrainHeight, terrain2DData.noiseIndex);
				if (weightCave > selectedNoise.caveThreshold)
				{
					isBlockCave = true;
				}

				if (blockPos.y == terrainHeight + 1)
				{
					//如果大于阈值则是空气 下方方块
					float weightCaveDown = CreateTerrainCaveData(float3(blockPos.x, blockPos.y - 1, blockPos.z), terrainHeight, terrain2DData.noiseIndex);
					if (weightCaveDown > selectedNoise.caveThreshold)
					{
						isBlockCaveDown = true;
					}
				}
				break;
			}
		}
		//创建水
		if (selectedNoise.oceanScale > 0)
		{
			//如果在水的区域内 不生成洞穴
			if (blockPos.y >= selectedNoise.oceanMinHeight && blockPos.y <= selectedNoise.oceanMaxHeight) 
			{
				isBlockCave = false;
				isBlockCaveDown = false;
			}
			//是否生成水
			if (blockPos.y > selectedNoise.oceanMinHeight && blockPos.y <= selectedNoise.oceanMaxHeight) 
			{
				weighOcean = CreateTerrainOceanData(blockPos, terrainHeight, terrain2DData.noiseIndex);
			}
			//下方方块是否是水
			if (blockPos.y - 1 > selectedNoise.oceanMinHeight && blockPos.y - 1 <= selectedNoise.oceanMaxHeight)
			{
			    weighOceanDown = CreateTerrainOceanData(float3(blockPos.x, blockPos.y - 1, blockPos.z), terrainHeight, terrain2DData.noiseIndex);
			}
		}
	}

	int4 biomeBlockData = int4(0, 0, 0, 0);
	//获取生态方块数据
	switch (selectedNoise.biomeId)
	{
	case 1://平原
		biomeBlockData = HandleBiomePrairie(seed, blockPos, blockIndex, terrainHeight,isBlockCave, isBlockCaveDown);
		break;
	case 2://森林
		biomeBlockData = HandleBiomeForest(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	case 3://沙漠
		biomeBlockData = HandleBiomeDesert(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	case 4://高山
		biomeBlockData = HandleBiomeMountain(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);	
		break;
	case 5://熔原
		biomeBlockData = HandleBiomePrairieLava(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);	
		break;
	case 6://海洋
		biomeBlockData = HandleBiomeOcean(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	case 7://湿地
		biomeBlockData = HandleBiomeSwamp(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	case 8://雪原
		biomeBlockData = HandleBiomeSnowland(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	case 11://魔法森林
		biomeBlockData = HandleBiomeForestMagic(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	case 12://白桦树森林
		biomeBlockData = HandleBiomeForestBirch(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	case 999://主界面
		biomeBlockData = HandleBiomeMain(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);	
		break;
	case 1001://腐化地牢 基础
		biomeBlockData = HandleBiomePutrefyDungeonBase(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	default:
		//biomeBlockData = HandleBiomePrairie(seed, blockPos, blockIndex, terrainHeight,isBlockCave, isBlockCaveDown);
		biomeBlockData = HandleBiomeForest(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		//biomeBlockData = HandleBiomeTest(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	}

	if (biomeBlockData.w == 1)
	{
		itemBlock.blockId = biomeBlockData.x;
		itemBlock.blockStructure = biomeBlockData.y;
	}

	//矿物处理 如果有矿物数据 并且当前不是洞穴 并且在地面以下
	if (oreDatasCount > 0 && !isBlockCave && weighOcean < selectedNoise.oceanThreshold && blockPos.y < terrainHeight - 5)
	{
		for (int i = 0; i < oreDatasCount; i++)
		{
			OreData itemOreData = oreDatasArrayBuffer[i];
			//矿石在此高度内
			if (blockPos.y >= itemOreData.oreMinHeight && blockPos.y <= itemOreData.oreMaxHeight)
			{
				float oreCreateRate = snoise(float4(blockPos / (i + 10), seed));
				if (oreCreateRate > itemOreData.oreDensity)
				{
					itemBlock.blockId = itemOreData.oreId;
					itemBlock.blockStructure = 0;
				}
			}
		}
	}

	//设置基岩
	switch (stateBedrock)
	{
	case 1:
		if (id.y <= 1)
		{
			itemBlock.blockId = 5;
		}
		break;
	}

	if (itemBlock.blockId != 0)
	{
		//blockCountBuffer.IncrementCounter();
		//也可以使用这种方式增加计数
		InterlockedAdd(blockCountBuffer[0], 1);
	}

	blockArrayBuffer[blockIndex] = itemBlock;
}
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel StartCreate

#include "Noise/SimplexNoiseCShader.compute"
#include "Biome/BiomeForestCShader.compute"
#include "Biome/BiomePrairieCShader.compute"
#include "Biome/BiomeTestCShader.compute"

//方块数据
struct BlockData
{
	//方块ID
	int blockId;
	//方块的结构 0普通方块
	int blockStructure;
};

//noise数据
struct NoiseLayer
{
	//生态ID
	int biomeId;
	//出现频率 数值越大 波峰越多
	float frequency;
	//振幅 数值越大 越宽
	float amplitude;
	//间隙性
	float lacunarity;
	//噪音循环迭代次数 复杂度
	int octaves;

	//洞穴高度
	int caveMinHeight;
	int caveMaxHeight;
	//洞穴大小
	float caveScale;
	//洞穴的阈值
	float caveThreshold;

	//洞穴出现频率 数值越大 波峰越多
	float caveFrequency;
	//洞穴振幅 数值越大 越宽
	float caveAmplitude;
	//洞穴循环迭代次数 复杂度
	int caveOctaves;

	//地面的最低高度
	int groundMinHeigh;
	//海面高度
	int oceanMinHeight;
	int oceanMaxHeight;
	//水的大小
	float oceanScale;
	//水的预制
	float oceanThreshold;
	//水的振幅 
	float oceanAmplitude;
	//水的频率 
	float oceanFrequency;
};

//矿石数据
struct OreData
{
	//矿石ID
	int oreId;
	//矿石密度
	float oreDensity;
	//矿石的范围
	int oreMinHeight;
	int oreMaxHeight;
};

//2D地形数据
struct Terrain2DData
{
	//高度
	uint height;
	//使用的noiseIndex
	uint noiseIndex;
};

//区块宽
uint chunkSizeW;
//区块高
uint chunkSizeH;
/*
洞穴状态
0 不创建洞穴
1 创建普通洞穴
*/
uint stateCaves;
/*
基岩状态
0 不创建基岩
1 创建普通基岩 y=0
*/
uint stateBedrock;
//区块位置
float3 chunkPosition;
//种子
int seed;
//种子偏移
float3 seedOffset;
//所有noise数据
StructuredBuffer<NoiseLayer> noiseLayersArrayBuffer;
int noiseLayersCount;
//矿石数据
StructuredBuffer<OreData> oreDatasArrayBuffer;
int oreDatasCount;
//所有的方块列表数据
RWStructuredBuffer<BlockData> blockArrayBuffer;
//不是空气方块的数量
RWStructuredBuffer<uint> blockCountBuffer;

//获取方块的序号
int GetBlockIndex(uint3 idx)
{
	return idx.x + (idx.y * chunkSizeW) + (idx.z * chunkSizeW * chunkSizeH);
}

//创建3D地形数据 暂时用于洞穴
float CreateTerrainCaveData(float3 blockPos, float terrainHeight, uint noiseIndex)
{
	//获取当前noise数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];

	float amplitude = 1;
	float frequency = 1;

	//3D地形的权重
	float weightCave = 0;

	//迭代次数
	for (int i = 0; i < selectedNoise.caveOctaves; i++)
	{
		weightCave += snoise(frequency * (blockPos / selectedNoise.caveScale)) * amplitude;
		frequency *= selectedNoise.caveFrequency;
		amplitude *= selectedNoise.caveAmplitude;
	}
	return weightCave;
}

//获取指定位置 2D地形的高度权重
float CreateTerrain2DWeightH(float2 blockPosXZ, uint noiseIndex)
{
	//获取当前noise数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];
	float weightH = 0;
	float amplitude = selectedNoise.amplitude;
	float3 posTempData = float3(blockPosXZ.xy, seed);
	//容错处理 0，0位置的高度有问题 使用1，1的高度
	if (posTempData.x == 0 && posTempData.y == 0)
	{
		posTempData.x = 1;
		posTempData.y = 0;
	}
	//迭代次数
	for (int i = 0; i < selectedNoise.octaves; i++)
	{
		//调取噪音计算 获取2D的权重高度 这里加上振幅和频率
		if (selectedNoise.frequency == 0)
		{
			//如果频率为0 则为0高度
			weightH += 0;
		}
		else
		{
			weightH += snoise(float3(posTempData.xy / selectedNoise.frequency, posTempData.z)) * amplitude;
		}
		//每次迭代改变间隙性
		posTempData.xy *= selectedNoise.lacunarity;
		//每次迭代改变振幅
		amplitude *= selectedNoise.amplitude;
	}
	weightH = weightH * weightH;
	return clamp(weightH, 0, 1);
}

//创建2D的地形数据
Terrain2DData CreateTerrain2DData(float3 blockPos)
{
	//噪音数据的序号  TODO 暂时只处理第一个
	uint noiseIndex = 0;
	//获取2D地形的权重高
	float weightH = CreateTerrain2DWeightH(blockPos.xz, noiseIndex);
	//获取当前的noise参数
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];
	//做一个容错。最高不超过区块的高-16
	float height = clamp((weightH * (chunkSizeH - 32)) + selectedNoise.groundMinHeigh, 0, chunkSizeH - 16);

	//获取左右前后的数据
	NoiseLayer selectedNoiseL = noiseLayersArrayBuffer[1];
	NoiseLayer selectedNoiseR = noiseLayersArrayBuffer[2];
	NoiseLayer selectedNoiseF = noiseLayersArrayBuffer[3];
	NoiseLayer selectedNoiseB = noiseLayersArrayBuffer[4];

	float posLocalX = blockPos.x - chunkPosition.x;
	float posLocalZ = blockPos.z - chunkPosition.z;

	float lerpHeightL = 0;
	float lerpHeightR = 0;
	float lerpHeightF = 0;
	float lerpHeightB = 0;
	//过度总数
	int lerpHeightMin = chunkSizeH + 1;
	//过度的方块数量
	int lerpBlockNum = 5;
	if (selectedNoiseL.biomeId != selectedNoise.biomeId && posLocalX >= 0 && posLocalX < lerpBlockNum)
	{
		float baseHeight = (selectedNoise.oceanMaxHeight + selectedNoiseL.oceanMaxHeight) / 2;
		lerpHeightL = lerp(height, baseHeight, 1 - (posLocalX / (lerpBlockNum - 1)));
		lerpHeightMin = lerpHeightL < lerpHeightMin ? lerpHeightL : lerpHeightMin;
	}
	if (selectedNoiseR.biomeId != selectedNoise.biomeId && posLocalX >= (chunkSizeW - lerpBlockNum) && posLocalX < chunkSizeW)
	{
		float baseHeight = (selectedNoise.oceanMaxHeight + selectedNoiseR.oceanMaxHeight) / 2;
		lerpHeightR = lerp(height, baseHeight, (posLocalX - (chunkSizeW - lerpBlockNum)) / (lerpBlockNum - 1));
		lerpHeightMin = lerpHeightR < lerpHeightMin ? lerpHeightR : lerpHeightMin;
	}
	if (selectedNoiseF.biomeId != selectedNoise.biomeId && posLocalZ >= 0 && posLocalZ < lerpBlockNum)
	{
		float baseHeight = (selectedNoise.oceanMaxHeight + selectedNoiseF.oceanMaxHeight) / 2;
		lerpHeightF = lerp(height, baseHeight, 1 - (posLocalZ / (lerpBlockNum - 1)));
		lerpHeightMin = lerpHeightF < lerpHeightMin ? lerpHeightF : lerpHeightMin;
	}
	if (selectedNoiseB.biomeId != selectedNoise.biomeId && posLocalZ >= (chunkSizeW - lerpBlockNum) && posLocalZ < chunkSizeW)
	{
		float baseHeight = (selectedNoise.oceanMaxHeight + selectedNoiseB.oceanMaxHeight) / 2;
		lerpHeightB = lerp(height, baseHeight, (posLocalZ - (chunkSizeW - lerpBlockNum)) / (lerpBlockNum - 1));
		lerpHeightMin = lerpHeightB < lerpHeightMin ? lerpHeightB : lerpHeightMin;
	}

	if (lerpHeightMin != chunkSizeH + 1)
	{
		height = lerpHeightMin;
	}

	Terrain2DData terrain2DData;
	terrain2DData.height = round(height);
	terrain2DData.noiseIndex = noiseIndex;
	return terrain2DData;
}

//创建3D定性数据 用于水
float CreateTerrainOceanData(float3 blockPos, float terrainHeight, uint noiseIndex)
{	
	//获取当前noise数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[noiseIndex];
	float weighOcean = 0;
	//迭代次数
	weighOcean += snoise(selectedNoise.oceanFrequency * (blockPos / selectedNoise.oceanScale)) * selectedNoise.oceanAmplitude;
	return weighOcean;
}

//根据生态生成数据 测试用
int4 HandleBiomeForTest(int seed, float3 blockPos, int blockIndex, uint terrainHeight, 
	bool isBlockCave, bool isBlockCaveDown,float weighOceanTarget, float weighOcean,float weighOceanDown)
{
    bool isBlockWater = weighOcean > weighOceanTarget ? true : false;
	bool isBlockWaterDown = weighOceanDown > weighOceanTarget ? true : false;
	if (isBlockWater) 
	{
		//如果又是水 又是洞穴 并且下方也是
		if (isBlockCave)
		{
			return int4(4, 0, 0, 1);
		}
		else if (isBlockCaveDown)
		{
			return int4(4, 0, 0, 1);
		}
		//靠近水区域显示沙子
		if(weighOcean > weighOceanTarget && weighOcean < weighOceanTarget + 0.05f)
		{
			return int4(3, 0, 0, 1);
		}
		return int4(9001, 0, 0, 1);
	}
	if (isBlockCave)
	{
		return int4(0, 0, 0, 1);
	}
	int4 targetBlockData = int4(0, 0, 0, 0);
	//如果大于地面高度
	if (blockPos.y > terrainHeight)
	{
		//如果是地面上一格
	    if (blockPos.y == terrainHeight + 1)
		{
			//如果下方不是洞穴 并且也不是水
			if (!isBlockCaveDown && !isBlockWaterDown)
			{
				//是否生成草
				bool isCreateWeedWild = snoise(float3(blockPos.xz / 10, seed)) > 0.3;
				//是否成成花
				bool isCreateFlower = snoise(float3(blockPos.xz / 9, seed)) > 0.8;
				//是否生成蘑菇
				bool isCreateMushroom = snoise(float3(blockPos.xz / 8, seed)) > 0.8;
				//是否生成浆果
				bool isCreateBerryBush = snoise(float3(blockPos.xz / 7, seed)) > 0.8;		

				//是否生成树
				bool isCreateTree = GenerateRandom(seed, blockPos.x, blockPos.z) > 0.98;
				//是否生成台石
				bool isCreateStoneMoss = GenerateRandom(seed, blockPos.x / 2, blockPos.z / 2) > 0.995;
				//是否生成枯木
				bool isCreateDeadWood = GenerateRandom(seed, blockPos.x / 3, blockPos.z / 3) > 0.9965;
				///是否生成倒下的树木
				bool isCreateFallDownTree = GenerateRandom(seed, blockPos.x / 4, blockPos.z / 4) > 0.995;
				//是否生成元素花
				bool isCreateElementFlower = GenerateRandom(seed, blockPos.x / 5, blockPos.z / 5) > 0.998;
				
				if (isCreateWeedWild)
				{
					float randomType = snoise(float4(blockPos, seed));
					if (randomType > 0 && randomType <= 0.25)
					{
						targetBlockData = int4(3001, 0, 0, 1);
					}
					else if (randomType > 0.25 && randomType <= 0.5)
					{
						targetBlockData = int4(3002, 0, 0, 1);
					}
					else if (randomType > 0.5 && randomType <= 0.75)
					{
						targetBlockData = int4(3003, 0, 0, 1);
					}
					else 
					{
						targetBlockData = int4(3004, 0, 0, 1);
					}
				}
				else if (isCreateFlower)
				{
					float randomType = snoise(float4(blockPos, seed));
					if (randomType > 0 && randomType <= 0.33)
					{
						targetBlockData = int4(3111, 0, 0, 1);
					}
					else if (randomType > 0.33 && randomType <= 0.66)
					{
						targetBlockData = int4(3112, 0, 0, 1);
					}
					else
					{
						targetBlockData = int4(3113, 0, 0, 1);
					}
				}
				else if(isCreateMushroom)
				{
					float randomType = snoise(float4(blockPos, seed));
					if (randomType > 0 && randomType <= 0.25)
					{
						targetBlockData = int4(3211, 0, 0, 1);
					}
					else if (randomType > 0.25 && randomType <= 0.5)
					{
						targetBlockData = int4(3212, 0, 0, 1);
					}
					else if(randomType > 0.5 && randomType <= 0.75)
					{
						targetBlockData = int4(3213, 0, 0, 1);
					}
					else
					{
						targetBlockData = int4(3202, 0, 0, 1);
					}
				}
				else if(isCreateBerryBush)
				{			
					float randomType = snoise(float4(blockPos, seed));
					if (randomType > 0 && randomType <= 0.5)
					{
						targetBlockData = int4(5902, 0, 0, 1);
					}
					else
					{
						targetBlockData = int4(5904, 0, 0, 1);
					}
				}
				else if (isCreateTree)
				{
					targetBlockData = int4(1001, 1, 0, 1);
				}
				else if(isCreateStoneMoss)
				{
					targetBlockData = int4(6, 0, 0, 1);
				}
				else if(isCreateDeadWood)
				{
					targetBlockData = int4(3301, 1001, 0, 1);
				}		
				else if(isCreateFallDownTree)
				{
					targetBlockData = int4(1001, 1002, 0, 1);
				}
				else if(isCreateElementFlower)
				{
					float randomType = snoise(float4(blockPos, seed));
					if (randomType > 0 && randomType <= 0.5)
					{
						targetBlockData = int4(3122, 0, 0, 1);
					}
					else
					{
						targetBlockData = int4(3123, 0, 0, 1);
					}
				}
			}
			else if(isBlockWaterDown)
			{
				//靠近水区域显示沙子
				if(weighOceanDown > weighOceanTarget && weighOceanDown < weighOceanTarget + 0.05f)
				{

				}
				else
				{
					//是否生成荷叶
					bool isCreateLotusLeaf = GenerateRandom(seed, blockPos.x, blockPos.z) > 0.9;
					if(isCreateLotusLeaf)
					{
						targetBlockData = int4(2221, 0, 0, 1);
					}
				}			
			}
			else
			{
				targetBlockData = int4(0, 0, 0, 1);
			}
		}
		else
		{
			targetBlockData = int4(0, 0, 0, 1);
		}
	}
	else if (blockPos.y == terrainHeight)
	{
		//使用荒草泥土
		targetBlockData = int4(101, 0, 0, 1);
	}
	else if (blockPos.y < terrainHeight && blockPos.y > terrainHeight - 6)
	{
		//使用泥土
		targetBlockData = int4(4, 0, 0, 1);
	}
	else
	{
		//使用石头
		targetBlockData = int4(5, 0, 0, 1);
	}
	return targetBlockData;
}

//开始生成数据
[numthreads(8, 8, 8)]
void StartCreate(uint3 id : SV_DispatchThreadID)
{
	//如果XZ大于W 则不处理
	if (any(id.xz > chunkSizeW))
		return;
	//获取方块下标
	int blockIndex = GetBlockIndex(id);
	//获取方块的世界坐标
	float3 blockPos = id + chunkPosition + seedOffset;
	//获取2D地形数据
	Terrain2DData terrain2DData = CreateTerrain2DData(blockPos);
	//获取2D地形的高
	uint terrainHeight = terrain2DData.height;
	//获取噪音数据
	NoiseLayer selectedNoise = noiseLayersArrayBuffer[terrain2DData.noiseIndex];

	BlockData itemBlock;
	itemBlock.blockId = 0;
	itemBlock.blockStructure = 0;


	//当前方块是否是洞穴
	bool isBlockCave = false;
	//下方方块是否是洞穴
	bool isBlockCaveDown = false;

	//权重 水
	float weighOcean = 0;
	float weighOceanDown = 0;
	//如果不是空气方块 并且在地表以下 则创建普通洞穴
	if (blockPos.y <= terrainHeight + 1)
	{
		if (blockPos.y >= selectedNoise.caveMinHeight && blockPos.y <= selectedNoise.caveMaxHeight)
		{
			//如果是需要创建普通洞穴
			switch (stateCaves)
			{
			case 1:
				//如果大于阈值则是空气
				float weightCave = CreateTerrainCaveData(blockPos, terrainHeight, terrain2DData.noiseIndex);
				if (weightCave > selectedNoise.caveThreshold)
				{
					isBlockCave = true;
				}

				if (blockPos.y == terrainHeight + 1)
				{
					//如果大于阈值则是空气 下方方块
					float weightCaveDown = CreateTerrainCaveData(float3(blockPos.x, blockPos.y - 1, blockPos.z), terrainHeight, terrain2DData.noiseIndex);
					if (weightCaveDown > selectedNoise.caveThreshold)
					{
						isBlockCaveDown = true;
					}
				}
				break;
			}
		}
		//创建水
		if (selectedNoise.oceanScale > 0)
		{
			//如果在水的区域内 不生成洞穴
			if (blockPos.y >= selectedNoise.oceanMinHeight && blockPos.y <= selectedNoise.oceanMaxHeight) 
			{
				isBlockCave = false;
				isBlockCaveDown = false;
			}
			//是否生成水
			if (blockPos.y > selectedNoise.oceanMinHeight && blockPos.y <= selectedNoise.oceanMaxHeight) 
			{
				weighOcean = CreateTerrainOceanData(blockPos, terrainHeight, terrain2DData.noiseIndex);
			}
			//下方方块是否是水
			if (blockPos.y - 1 > selectedNoise.oceanMinHeight && blockPos.y - 1 <= selectedNoise.oceanMaxHeight)
			{
			    weighOceanDown = CreateTerrainOceanData(float3(blockPos.x, blockPos.y - 1, blockPos.z), terrainHeight, terrain2DData.noiseIndex);
			}
		}
	}

	int4 biomeBlockData = int4(0, 0, 0, 0);
	//获取生态方块数据
	switch (selectedNoise.biomeId)
	{
	//case 1://平原
		//biomeBlockData = HandleBiomePrairie(seed, blockPos, blockIndex, terrainHeight,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		//break;
		//case 2://森林
		//	biomeBlockData = HandleBiomeForest(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		//	break;
		//case 998://测试生态
		//	biomeBlockData = HandleBiomeTest(blockPos, blockIndex, terrainHeight);
		//	break;
	default:
		biomeBlockData = HandleBiomeForTest(seed, blockPos, blockIndex, terrainHeight, isBlockCave, isBlockCaveDown,selectedNoise.oceanThreshold, weighOcean,weighOceanDown);
		break;
	}

	if (biomeBlockData.w == 1)
	{
		itemBlock.blockId = biomeBlockData.x;
		itemBlock.blockStructure = biomeBlockData.y;
	}

	//矿物处理 如果有矿物数据 并且当前不是洞穴 并且在地面以下
	if (oreDatasCount > 0 && !isBlockCave && weighOcean < selectedNoise.oceanThreshold && blockPos.y < terrainHeight - 5)
	{
		for (int i = 0; i < oreDatasCount; i++)
		{
			OreData itemOreData = oreDatasArrayBuffer[i];
			//矿石在此高度内
			if (blockPos.y >= itemOreData.oreMinHeight && blockPos.y <= itemOreData.oreMaxHeight)
			{
				float oreCreateRate = snoise(float4(blockPos / (i + 10), seed));
				if (oreCreateRate > itemOreData.oreDensity)
				{
					itemBlock.blockId = itemOreData.oreId;
					itemBlock.blockStructure = 0;
				}
			}
		}
	}

	//设置基岩
	switch (stateBedrock)
	{
	case 1:
		if (id.y <= 1)
		{
			itemBlock.blockId = 5;
		}
		break;
	}

	if (itemBlock.blockId != 0)
	{
		//blockCountBuffer.IncrementCounter();
		//也可以使用这种方式增加计数
		InterlockedAdd(blockCountBuffer[0], 1);
	}

	blockArrayBuffer[blockIndex] = itemBlock;
}